runtime bundle/vim-pathogen/autoload/pathogen.vim
" Bundle: tpope/vim-pathogen
call pathogen#infect()

" vim-update-bundles

" Bundle: tpope/vim-sensible
" Bundle: wincent/Command-T
" BundleCommand: rvm system do rake make
" Bundle: amiel/vim-tmux-navigator
" Bundle: tpope/vim-rails
" Bundle: rking/ag.vim
" Bundle: tpope/vim-fugitive
" Bundle: jgdavey/vim-blockle
" Bundle: vim-coffee-script
" Bundle: commentary.vim
" Bundle: tpope/vim-dispatch
" Bundle: endwise.vim
" Bundle: nono/vim-handlebars
" Bundle: tpope/vim-repeat
" Bundle: t9md/vim-ruby-xmpfilter
" Bundle: tpope/vim-surround
" Bundle: tpope/vim-tbone
" Bundle: pangloss/vim-javascript
" Bundle: mattn/emmet-vim
" Bundle: bling/vim-airline
" Bundle: airblade/vim-gitgutter
" Bundle: scrooloose/syntastic



let mapleader = ","


set nocompatible
syntax enable
set encoding=utf-8
set mouse=a
" Keep open files hidden (doesn't require you to save files to switch away
" from them)
set hidden
filetype plugin indent on

" set shortmess=atI

set nrformats=hex,alpha

set expandtab
set shiftwidth=2
set softtabstop=2

set wrap
set textwidth=80
set formatoptions=qcron1
set colorcolumn=96

set cursorline

set hlsearch

set number " show numbers
set relativenumber " but relative to the cursor

" make searches case-sensitive only if they contain upper-case characters
set ignorecase smartcase

" We have to have a winheight bigger than we want to set winminheight. But if
" we set winheight to be huge before winminheight, the winminheight set will
" fail.
set noequalalways

set winheight=5 winminheight=5
set winwidth=12 winminwidth=12
set winheight=9999 winwidth=96




set scrolloff=4

set switchbuf=useopen,split

set autoread

" set ruler

" keep undo information even after we quit
set undofile

set backup
set backupdir=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
set directory=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
set undodir=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
set backupskip=/tmp/*,/private/tmp/*

set wildmode=longest,list
set wildmenu



set wildignore+=*vim/backups*
set wildignore+=*sass-cache*
set wildignore+=*DS_Store*
set wildignore+=vendor/rails/**
set wildignore+=vendor/cache/**
set wildignore+=*.gem
set wildignore+=log/**
set wildignore+=.git
set wildignore+=tmp/cache
set wildignore+=*.png,*.jpg,*.gif

set list



" http://items.sjbach.com/319/configuring-vim-right
" extends % to match more things correctly
runtime macros/matchit.vim


""""""""""""
" Syntastic
""""""""""""
let g:syntastic_html_tidy_ignore_errors = ['trimming empty']
let g:syntastic_error_symbol='✗'
let g:syntastic_warning_symbol='⚠'
let g:syntastic_javascript_checkers = ['jshint']

""""""""""""""
" Airline
""""""""""""""


" set statusline=%<%f\ (%{&ft})\ %-4(%m%)%=%-19(%3l,%02c%03V%)

set ttimeoutlen=50
let g:airline_powerline_fonts = 1
" let g:airline#extensions#hunks#enabled = 0
let g:airline#extensions#hunks#non_zero_only = 1
let g:airline_theme = 'custom'

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" COLOR
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
:set t_Co=256 " 256 colors
:set background=dark
" :color Tomorrow-Night-Eighties
" :color grb256

highlight ColorColumn term=NONE ctermbg=233 ctermfg=NONE guibg=NONE
highlight cursorline cterm=NONE ctermbg=234 term=NONE guibg=NONE
highlight LineNr ctermfg=239
highlight SpecialKey term=NONE ctermfg=238 guifg=NONE
highlight SignColumn ctermbg=NONE guibg=NONE
highlight NonText ctermfg=black

highlight DiffAdd term=reverse cterm=bold ctermbg=green ctermfg=white
highlight DiffChange term=reverse cterm=bold ctermbg=cyan ctermfg=black
highlight DiffText term=reverse cterm=bold ctermbg=gray ctermfg=black
highlight DiffDelete term=reverse cterm=bold ctermbg=red ctermfg=black

highlight VertSplit term=NONE cterm=NONE ctermbg=238 ctermfg=238

" from something else...
" highlight! link DiffText MatchParen




""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" MISC KEY MAPS
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" center cursor position in screen
nmap <space> zz

map <leader>y "*y

" Move around splits with <c-hjkl>
nnoremap <c-j> <c-w>j
nnoremap <c-k> <c-w>k
nnoremap <c-h> <c-w>h
nnoremap <c-l> <c-w>l

nnoremap <c-w><c-o> <c-w>r

nnoremap <c-s> <c-w>j<c-w>=
" nnoremap <c-+> <c-w>+
" nnoremap <c--> <c-w>-



" New vertical split, switch to it
nnoremap <leader>w <C-w>v<C-w>l
" New horiz split, switch to it
nnoremap <leader>s <C-w>s<C-w>j

" tab navigation like firefox
nnoremap <C-S-tab> :tabprevious<CR>
nnoremap <C-tab>   :tabnext<CR>
nnoremap <C-t>     :tabnew<CR>
inoremap <C-S-tab> <Esc>:tabprevious<CR>i
inoremap <C-tab>   <Esc>:tabnext<CR>i
inoremap <C-t>     <Esc>:tabnew<CR>

" CTRL+A moves to start of line in command mode
cnoremap <C-a> <home>
" CTRL+E moves to end of line in command mode
cnoremap <C-e> <end>

" Insert a hash rocket with <c-l>
imap <c-l> <space>=><space>
" Can't be bothered to understand ESC vs <c-c> in insert mode
imap <c-c> <esc>

" visual shifting (does not exit Visual mode)
vnoremap < <gv
vnoremap > >gv

nmap <silent> <leader>/ :nohlsearch<CR>
nnoremap <leader><leader> <c-^>

" Use real regexes for searches
nnoremap / /\v
vnoremap / /\v

map ,= mzgg=G`z



" Edit or view files in same directory as current file
cnoremap %% <C-R>=expand('%:h').'/'<cr>
map <leader>e :edit %%
map <leader>v :view %%


" nmap <silent> <leader>r mzggVG!xmpfilter -a<cr>'z
nmap <buffer> <leader>r   <Plug>(xmpfilter-run)

" nmap <buffer> <F5> <Plug>(xmpfilter-run)
" xmap <buffer> <F5> <Plug>(xmpfilter-run)
" imap <buffer> <F5> <Plug>(xmpfilter-run)

" nmap <buffer> <F6> <Plug>(xmpfilter-mark)
" xmap <buffer> <F6> <Plug>(xmpfilter-mark)
" imap <buffer> <F6> <Plug>(xmpfilter-mark)

nnoremap <leader>. :A<cr>




" Command-T mappings

"let g:CommandTMatchWindowAtTop=1


" Open files with <leader>h
map <leader>h :CommandT<cr>
map <leader>f :CommandTFlush<cr>\|:CommandT<cr>
" Open files, limited to the directory of the current file, with <leader>gf
" This requires the %% mapping found below.
map <leader>nh :CommandTFlush<cr>\|:CommandT %%<cr>
map <leader>nb :CommandTFlush<cr>\|:CommandTBuffer<cr>

map <leader>nad :CommandT app/admin<cr>
map <leader>nas :CommandT app/assets<cr>
map <leader>nv :CommandTFlush<cr>\|:CommandT app/views<cr>
map <leader>nc :CommandTFlush<cr>\|:CommandT app/controllers<cr>
map <leader>nm :CommandTFlush<cr>\|:CommandT app/models<cr>
map <leader>nj :CommandTFlush<cr>\|:CommandT app/assets/javascripts<cr>
map <leader>nl :CommandTFlush<cr>\|:CommandT lib<cr>
map <leader>np :CommandTFlush<cr>\|:CommandT public<cr>
map <leader>ns :CommandTFlush<cr>\|:CommandT spec<cr>


map <leader>gg :topleft 100 :split Gemfile<cr>
map <leader>gr :topleft :split config/routes.rb<cr>

map <leader>ne :call CommandTInRailsEngine()<cr>
map <leader>gR :call ShowRoutes()<cr>

function! CommandTInRailsEngine()
    let in_engine_file = match(expand("%"), '^engines/.\+$') != -1

    if in_engine_file
      let engine_dir = substitute(expand("%"), '^\(engines/\w\+\)/.*$', '\1', '')
      exec ":CommandT " . engine_dir
    endif
endfunction

" Rake Routes

function! ShowRoutes()
  " Requires 'scratch' plugin
  :topleft 100 :split __Routes__
  " Make sure Vim doesn't write __Routes__ as a file
  :set buftype=nofile
  " Delete everything
  :normal 1GdG
  " Put routes output in buffer
  :0r! rake -s routes
  " Size window to number of lines (1 plus rake output length)
  " :exec ":normal " . line("$") . _ "
  " Move cursor to bottom
  :normal 1GG
  " Delete empty trailing line
  :normal dd
endfunction



"""""""""""""""""""""""""""""""""""
" Show coverage report if it exists
"""""""""""""""""""""""""""""""""""

function! SetupCoverage()
  if filereadable("coverage.vim")
    source coverage.vim
  endif
endfunction

if has("autocmd")
  " Remove trailing whitespace on save
  autocmd BufWritePre * :%s/\s\+$//e

  " Source the vimrc file after saving it
  " autocmd bufwritepost .vimrc source $MYVIMRC

  autocmd BufNewFile,BufRead Gemfile,Rakefile,Guardfile,Capfile,config.ru setlocal filetype=ruby
  autocmd FileType rb set makeprg=rake
  autocmd FileType ruby call SetupCoverage()

  autocmd InsertEnter * :set number
  autocmd InsertLeave * :set relativenumber

  :au FocusLost * :set number
  :au FocusGained * :set relativenumber

  " if exists("did_load_filetypes")
  "   finish
  " endif
  set runtimepath+=/usr/local/share/lilypond/2.16.2/vim/

  augroup filetypedetect
    au! BufNewFile,BufRead *.ly,*.ily           setf lilypond
  augroup END

  augroup windows
    autocmd!
    autocmd VimResized * :wincmd = " resize splits when the window is resized
  augroup END
endif







""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" RUNNING TESTS
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
map <leader>t :call RunTestFile()<cr>
map <leader>T :call RunNearestTest()<cr>
map <leader>a :call RunTests('')<cr>

function! RunTestFile(...)
    if a:0
        let command_suffix = a:1
    else
        let command_suffix = ""
    endif

    " Run the tests for the previously-marked file.
    let in_test_file = match(expand("%"), '\(.feature\|_spec.rb\|_test.rb\)$') != -1
    if in_test_file
        call SetTestFile()
    elseif !exists("t:grb_test_file")
        return
    end
    call RunTests(t:grb_test_file . command_suffix)
endfunction

function! RunNearestTest()
    let spec_line_number = line('.')
    call RunTestFile(":" . spec_line_number . " -b")
endfunction

function! SetTestFile()
    " Set the spec file that tests will be run for.
    let t:grb_test_file=@%
endfunction

function! DispatchTests(command)
  let command = a:command

  " if filereadable(".ruby-version")
  "   let ruby_version = "`cat .ruby-version`"
  "   if filereadable(".ruby-gemset")
  "     let ruby_version = ruby . "@`cat .ruby-gemset`"
  "   endif
  " endif


  exec ":Dispatch " . a:command
endfunction

function! RunTests(filename)
    :w
    if filereadable("script/test")
      call DispatchTests("script/test " . a:filename)
    elseif filereadable("Gemfile")
      call DispatchTests("bundle exec rspec --color " . a:filename)
    else
      call DispatchTests("rspec --color " . a:filename)
    end
endfunction



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" MULTIPURPOSE TAB KEY
" Indent if we're at the beginning of a line. Else, do completion.
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
function! InsertTabWrapper()
    let col = col('.') - 1
    if !col || getline('.')[col - 1] !~ '\k'
        return "\<tab>"
    else
        return "\<c-n>"
    endif
endfunction
inoremap <tab> <c-r>=InsertTabWrapper()<cr>
inoremap <s-tab> <c-n>



""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" PROMOTE VARIABLE TO RSPEC LET
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
function! PromoteToLet()
  :normal! dd
  " :exec '?^\s*it\>'
  :normal! P
  :.s/\(\w\+\) = \(.*\)$/let(:\1) { \2 }/
  :normal ==
endfunction
:command! PromoteToLet :call PromoteToLet()
:map <leader>p :PromoteToLet<cr>



" Copy the entire contents of the current file to the system clipboard
" This is useful for folks that do not have vim compiled with X bindings
" to use the " register
function! CopyFileToClipboard()
  :!cat %|pbcopy
endfunction
:command! CopyFile :call CopyFileToClipboard()

function! MakeDirectoryForCurrentFile()
  :!mkdir -p -v %:h
endfunction
:command! Mkdir :call MakeDirectoryForCurrentFile()

